/* See COPYRIGHT for copyright information. */

#include <inc/x86.h>
#include <inc/mmu.h>
#include <inc/error.h>
#include <inc/string.h>
#include <inc/assert.h>

#include <kern/pmap.h>
#include <kern/kclock.h>

#include <inc/stdio.h>
#include <inc/memlayout.h>

// These variables are set by i386_detect_memory()
size_t npages;			// Amount of physical memory (in pages)
static size_t npages_basemem;	// Amount of base memory (in pages)

// These variables are set in mem_init()
pde_t *kern_pgdir;		// Kernel's initial page directory
struct PageInfo *pages;		// Physical page state array
static struct PageInfo *page_free_list;	// Free list of physical pages

#define PT_NUMBER 1


// --------------------------------------------------------------
// Detect machine's physical memory setup.
// --------------------------------------------------------------

static int
nvram_read(int r)
{
	return mc146818_read(r) | (mc146818_read(r + 1) << 8);
}

static void
i386_detect_memory(void)
{
	size_t basemem, extmem, ext16mem, totalmem;

	// Use CMOS calls to measure available base & extended memory.
	// (CMOS calls return results in kilobytes.)
	basemem = nvram_read(NVRAM_BASELO);
	extmem = nvram_read(NVRAM_EXTLO);
	ext16mem = nvram_read(NVRAM_EXT16LO) * 64;

	// Calculate the number of physical pages available in both base
	// and extended memory.
	if (ext16mem)
		totalmem = 16 * 1024 + ext16mem;
	else if (extmem)
		totalmem = 1 * 1024 + extmem;
	else
		totalmem = basemem;

	npages = totalmem / (PGSIZE / 1024);
	npages_basemem = basemem / (PGSIZE / 1024);

	cprintf("Physical memory: %uK available, base = %uK, extended = %uK\n",
		totalmem, basemem, totalmem - basemem);
}


// --------------------------------------------------------------
// Set up memory mappings above UTOP.
// --------------------------------------------------------------

static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm);
static void check_page_free_list(bool only_low_memory);
static void check_page_alloc(void);
static void check_kern_pgdir(void);
static physaddr_t check_va2pa(pde_t *pgdir, uintptr_t va);
static void check_page(void);
static void check_page_installed_pgdir(void);

// This simple physical memory allocator is used only while JOS is setting
// up its virtual memory system.  page_alloc() is the real allocator.
//
// If n>0, allocates enough pages of contiguous physical memory to hold 'n'
// bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
//
// If n==0, returns the address of the next free page without allocating
// anything.
//
// If we're out of memory, boot_alloc should panic.
// This function may ONLY be used during initialization,
// before the page_free_list list has been set up.
static void *
boot_alloc(uint32_t n)
{
	static char *nextfree;	// virtual address of next byte of free memory
	char *result;

	// Initialize nextfree if this is the first time.
	// 'end' is a magic symbol automatically generated by the linker,
	// which points to the end of the kernel's bss segment:
	// the first virtual address that the linker did *not* assign
	// to any kernel code or global variables.
	if (!nextfree) {
		extern char end[];
		nextfree = ROUNDUP((char *) end, PGSIZE);
	}
    cprintf("nextfree initialize as %x\n", nextfree);

	// Allocate a chunk large enough to hold 'n' bytes, then update
	// nextfree.  Make sure nextfree is kept aligned
	// to a multiple of PGSIZE.
	//
	// LAB 2: Your code here.
    uint32_t addr = 0;
    if(n > 0)
    {
        addr = (uint32_t)nextfree;
        nextfree = (char *)(nextfree + ((n/PGSIZE) + (n%PGSIZE ? 1:0)) * PGSIZE);
        cprintf("addr = %x, n = %d, number of page = %d, nextfree = %x\n", addr, n, (n/PGSIZE + (n%PGSIZE?1:0)), nextfree);
    }
    else if(n == 0)
    {
        addr = (uint32_t)nextfree;
        cprintf("addr = %x, n = 0\n", addr);
    }
    else
    {
        cprintf("Invalid addr!\n");
    }
    return (void *)addr;
//	return NULL;
}

// Set up a two-level page table:
//    kern_pgdir is its linear (virtual) address of the root
//
// This function only sets up the kernel part of the address space
// (ie. addresses >= UTOP).  The user part of the address space
// will be set up later.
//
// From UTOP to ULIM, the user is allowed to read but not write.
// Above ULIM the user cannot read or write.
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;

	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	// Remove this line when you're ready to test this function.
//	panic("mem_init: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory.
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
	memset(kern_pgdir, 0, PGSIZE);

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P;
    cprintf("UVPT = %x, PDX(UVPT) = %x, PADDR = %x\n", UVPT, PDX(UVPT), PADDR(kern_pgdir));

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
    void *tb_addr = (void *)boot_alloc(PGSIZE);
    pages = (struct PageInfo *)boot_alloc(npages * sizeof(struct PageInfo));
    cprintf("sizeof(PageInfo) = %d, pages = %x, npages = %d\n", sizeof(struct PageInfo), pages, npages);
    memset(pages, 0, sizeof(struct PageInfo) * npages);
    cprintf("initialise pageinfo to 0 end\n");

	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
    cprintf("check page free list end\n");
	check_page_alloc();
    cprintf("check page alloc end\n");
	check_page();
    cprintf("check page end\n");

	//////////////////////////////////////////////////////////////////////
	// Now we set up virtual memory

	//////////////////////////////////////////////////////////////////////
	// Map 'pages' read-only by the user at linear address UPAGES
	// Permissions:
	//    - the new image at UPAGES -- kernel R, user R
	//      (ie. perm = PTE_U | PTE_P)
	//    - pages itself -- kernel RW, user NONE
	// Your code goes here:

    pte_t *ptpages = NULL;
    physaddr_t paptpages = (physaddr_t)PTE_ADDR(kern_pgdir[PDX(UPAGES)]);
    if(!paptpages)
    {
        struct PageInfo *pgptpages = page_alloc(ALLOC_ZERO);
        if(!pgptpages)
        {
            panic("page alloc for page table of pages failure\n");
        }
        paptpages = page2pa(pgptpages);
        kern_pgdir[PDX(UPAGES)] = paptpages | PTE_U | PTE_P;
        pgptpages->pp_ref++;

        ptpages = (pde_t *)(kern_pgdir[PDX(UPAGES)]);
    }

    ptpages = page2kva(pa2page(paptpages));
    uint32_t npage = npages*sizeof(struct PageInfo)/PGSIZE;
    for(uint32_t i = 0; i < npage; i++)
    {
        ptpages[PTX(UPAGES + i*PGSIZE)] = PADDR((uint8_t *)pages + i*PGSIZE) | PTE_U | PTE_P;
    }

	//////////////////////////////////////////////////////////////////////
	// Use the physical memory that 'bootstack' refers to as the kernel
	// stack.  The kernel stack grows down from virtual address KSTACKTOP.
	// We consider the entire range from [KSTACKTOP-PTSIZE, KSTACKTOP)
	// to be the kernel stack, but break this into two pieces:
	//     * [KSTACKTOP-KSTKSIZE, KSTACKTOP) -- backed by physical memory
	//     * [KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE) -- not backed; so if
	//       the kernel overflows its stack, it will fault rather than
	//       overwrite memory.  Known as a "guard page".
	//     Permissions: kernel RW, user NONE
	// Your code goes here:
    pte_t *ptstack = NULL;
    physaddr_t paptstack = (physaddr_t)PTE_ADDR(kern_pgdir[PDX(KSTACKTOP)]);
   
    cprintf("paptstack = %x\n", paptstack);
    if(!paptstack)
    {
        struct PageInfo *pgptstack = page_alloc(ALLOC_ZERO);
        if(!pgptstack)
        {
            panic("page alloc for page table of KSTACKTOP failure\n");
        }
        paptstack = page2pa(pgptstack);
        cprintf("alloc new page for stack, paptstack = %x\n", paptstack);
        kern_pgdir[PDX(KSTACKTOP - PTSIZE)] = paptstack | PTE_U | PTE_P;
        pgptstack->pp_ref++;

        ptstack = (pte_t *)kern_pgdir[PDX(KSTACKTOP)];
    }

    ptstack = (pte_t *)page2kva(pa2page(paptstack));
    cprintf("bootstack = %x, PADDR(bootstack) = %x\n", bootstack, PADDR(bootstack));
    for(uint32_t i = 0; i < KSTKSIZE/PGSIZE; i++)
    {
        ptstack[PTX(KSTACKTOP - KSTKSIZE + i*PGSIZE)] = (PADDR(bootstack) + i*PGSIZE) | PTE_W | PTE_P;
        cprintf("KSTACKTOP - KSTKSIZE + %d*PGSIZE = %x\n", i, KSTACKTOP - KSTKSIZE + i*PGSIZE);
        cprintf("PTX(KSTACKTOP - KSTKSIZE +  i*PGSIZE) = %x, ptstack[PTX] = %x\n", PTX(KSTACKTOP -KSTKSIZE +  i*PGSIZE), ptstack[PTX(KSTACKTOP - KSTKSIZE + i*PGSIZE)]);
        cprintf("RADDR(bootstack) = %x, PADDR(bootstack) - %d*PGSIZE = %x\n", PADDR(bootstack), i, PADDR(bootstack) - i*PGSIZE);
    }

	//////////////////////////////////////////////////////////////////////
	// Map all of physical memory at KERNBASE.
	// Ie.  the VA range [KERNBASE, 2^32) should map to
	//      the PA range [0, 2^32 - KERNBASE)
	// We might not have 2^32 - KERNBASE bytes of physical memory, but
	// we just set up the mapping anyway.
	// Permissions: kernel RW, user NONE
	// Your code goes here:
    for(uintptr_t kb = KERNBASE; kb <= 0xffc00000; )
    {
        pte_t *pt = (pte_t *)kern_pgdir[PDX(kb)];
        cprintf("pt = %x, PDX = %x\n", pt, PDX(kb));
        if(!pt)
        {
            cprintf("va = %x, PDX(%x) = %x has no page table in pgdir\n", kb, pt, PDX(kb));
            struct PageInfo *pgpd = page_alloc(ALLOC_ZERO);
            if(!pgpd)
            {
                cprintf("has no page for pd\n");
                break;
            }

            physaddr_t papd = page2pa(pgpd);
            kern_pgdir[PDX(kb)] = papd | PTE_W | PTE_P;
            cprintf("PDX(%x) = %x, kern_pgdir[%x] = %x\n", kb, PDX(kb), PDX(kb), kern_pgdir[PDX(kb)]);
            pt = (pte_t *)kern_pgdir[PDX(kb)];
            pgpd->pp_ref++;

            cprintf("alloc new page for pt = %x\n", pt);
        }

        pt = (pte_t *)KADDR(PTE_ADDR(pt));
        cprintf("&kern_pgdir[PDX] = %x, pt = %x, va = %x, PDX(%x) = %x\n", &kern_pgdir[PDX(kb)], pt, kb, kb, PDX(kb));

        physaddr_t pa = kb - KERNBASE;
        cprintf("kb - KERNBASE = %x\n", pa);

        for(uint32_t i = 0; i < PGSIZE/4; i++)
        {
            pt[i] = (pa + i*PGSIZE) | PTE_W | PTE_P;
 //           cprintf("&pt[%d] = %x, pt[%d] = %x, kb = %x, kb + %d*PGSIZE = %x\n", i, &pt[i], i, pt[i], kb, i, kb + i*PGSIZE);
        }
        uintptr_t pre_kb = kb;
        kb = kb + PGSIZE*PGSIZE/4;
        if(kb < pre_kb)
        {
            cprintf("Top of kernel space\n");
            break;
        }
        cprintf("later kb = %x\n", kb);
    }


	// Check that the initial page directory has been set up correctly.
	check_kern_pgdir();

	// Switch from the minimal entry page directory to the full kern_pgdir
	// page table we just created.	Our instruction pointer should be
	// somewhere between KERNBASE and KERNBASE+4MB right now, which is
	// mapped the same way by both page tables.
	//
	// If the machine reboots at this point, you've probably set up your
	// kern_pgdir wrong.
	lcr3(PADDR(kern_pgdir));

    cprintf("lcr3 end, check page start\n");
	check_page_free_list(0);
    cprintf("check page end\n");

	// entry.S set the really important flags in cr0 (including enabling
	// paging).  Here we configure the rest of the flags that we care about.
	cr0 = rcr0();
	cr0 |= CR0_PE|CR0_PG|CR0_AM|CR0_WP|CR0_NE|CR0_MP;
	cr0 &= ~(CR0_TS|CR0_EM);
	lcr0(cr0);

    cprintf("lcr0 end, check page installed start\n");
	// Some more checks, only possible after kern_pgdir is installed.
	check_page_installed_pgdir();
    cprintf("check page installed end\n");
}

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// --------------------------------------------------------------

//
// Initialize page structure and memory free list.
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!

    uint32_t iohole_pgstart = IOPHYSMEM / PGSIZE;
    uint32_t iohole_pgend   = EXTPHYSMEM / PGSIZE;

    uint32_t u_pgstart = iohole_pgend; 
    uint32_t u_pgend   = (uint32_t)(PADDR(boot_alloc(0))) / PGSIZE;

    cprintf("page_init start\n");
    cprintf("io start = %d, io end = %d, u start = %d, u end = %d, ps_end = %x\n", iohole_pgstart, iohole_pgend, u_pgstart, u_pgend, boot_alloc(0));

	size_t i;
	for (i = 0; i < npages; i++) {
        
        if(i == 0)
        {
            cprintf("preserve 0 page\n");
            continue;
        }
        else if(i >= iohole_pgstart && i < iohole_pgend)
        {
            continue;
        }
        else if(i >= u_pgstart && i < u_pgend)
        {
            continue;
        }

        pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
//        cprintf("page addr = %x, free list = %x, next list = %x, paddr = %x\n", &pages[i], page_free_list, page_free_list->pp_link, page2pa(page_free_list));
	}
    cprintf("page_init end\n");
}

//
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
    cprintf("alloc start\n"); 
    struct PageInfo *page = page_free_list;
    if(page == NULL)
    {
        cprintf("has no page to allocate\n");
        return NULL;
    }
    page_free_list = page_free_list->pp_link;

    if(page_free_list->pp_link == NULL)
    {
        cprintf("next is NULL\n");
    }

    cprintf("page addr = %x, free_list->next = %x\n", page, page_free_list);
    
    void *pgva = (void *)page2kva(page);
    cprintf("page = %x, pgva = %x\n", page, pgva);
    if(alloc_flags & ALLOC_ZERO)
    {
        cprintf("alloc_flags = %x, set value of pgva = 0\n", alloc_flags);
        memset(pgva, 0, PGSIZE);
    }
    cprintf("set page = %x pp_link to NULL\n", page); 
    page->pp_link = NULL;
    cprintf("alloc end\n"); 
	return page;
}

//
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
    if((pp->pp_ref) || (pp->pp_link != NULL))
    {
        panic("pp_ref != 0 or pp_link != NULL\n");
    }
    
    void *pgva = page2kva(pp);
    memset(pgva, 0, PGSIZE);

    pp->pp_link = page_free_list;
    page_free_list = pp;
}

//
// Decrement the reference count on a page,
// freeing it if there are no more refs.
//
void
page_decref(struct PageInfo* pp)
{
    cprintf("page_decref start, pp = %x, ref = %d\n", pp, pp->pp_ref);
	if (--pp->pp_ref == 0)
		page_free(pp);
    cprintf("page_decref end, pp = %x, ref = %d\n", pp, pp->pp_ref);
}

// Given 'pgdir', a pointer to a page directory, pgdir_walk returns
// a pointer to the page table entry (PTE) for linear address 'va'.
// This requires walking the two-level page table structure.
//
// The relevant page table page might not exist yet.
// If this is true, and create == false, then pgdir_walk returns NULL.
// Otherwise, pgdir_walk allocates a new page table page with page_alloc.
//    - If the allocation fails, pgdir_walk returns NULL.
//    - Otherwise, the new page's reference count is incremented,
//	the page is cleared,
//	and pgdir_walk returns a pointer into the new page table page.
//
// Hint 1: you can turn a PageInfo * into the physical address of the
// page it refers to with page2pa() from kern/pmap.h.
//
// Hint 2: the x86 MMU checks permission bits in both the page directory
// and the page table, so it's safe to leave permissions in the page
// directory more permissive than strictly necessary.
//
// Hint 3: look at inc/mmu.h for useful macros that manipulate page
// table and page directory entries.
//
pte_t *
pgdir_walk(pde_t *pgdir, const void *va, int create)
{
	// Fill this function in
    cprintf("pgdir_walk start\n");
    pte_t *pte = NULL, *pt = NULL;
    physaddr_t ptpa = PTE_ADDR(pgdir[PDX(va)]);
    
    cprintf("pgdir_walk, ptpa = %x, PDX(va) = %d\n", ptpa, PDX(va));
    if(!ptpa)
    {
        if(!create)
        {
            cprintf("pgdir_walk, did not find pdr for va = %x, return NULL\n", va);
            return NULL;
        }

        struct PageInfo *ps = page_alloc(ALLOC_ZERO);
        if(!ps)
            return NULL;
        
        ps->pp_ref++;
        ptpa = page2pa(ps);
        cprintf("pgdir_walk, new page for pt = %x\n", ptpa);

        pgdir[PDX(va)] = ptpa | PTE_P | PTE_U | PTE_W;
    }
    pt  = (pte_t *)page2kva(pa2page(ptpa));    
    pte = pt + PTX(va);
    cprintf("pgdir_walk, PTX = %d\n", PTX(va));
    cprintf("pgdir_walk end, pte = %x\n", pte);
    return pte;
}

//
// Map [va, va+size) of virtual address space to physical [pa, pa+size)
// in the page table rooted at pgdir.  Size is a multiple of PGSIZE, and
// va and pa are both page-aligned.
// Use permission bits perm|PTE_P for the entries.
//
// This function is only intended to set up the ``static'' mappings
// above UTOP. As such, it should *not* change the pp_ref field on the
// mapped pages.
//
// Hint: the TA solution uses pgdir_walk
static void
boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)
{
	// Fill this function in
}

//
// Map the physical page 'pp' at virtual address 'va'.
// The permissions (the low 12 bits) of the page table entry
// should be set to 'perm|PTE_P'.
//
// Requirements
//   - If there is already a page mapped at 'va', it should be page_remove()d.
//   - If necessary, on demand, a page table should be allocated and inserted
//     into 'pgdir'.
//   - pp->pp_ref should be incremented if the insertion succeeds.
//   - The TLB must be invalidated if a page was formerly present at 'va'.
//
// Corner-case hint: Make sure to consider what happens when the same
// pp is re-inserted at the same virtual address in the same pgdir.
// However, try not to distinguish this case in your code, as this
// frequently leads to subtle bugs; there's an elegant way to handle
// everything in one code path.
//
// RETURNS:
//   0 on success
//   -E_NO_MEM, if page table couldn't be allocated
//
// Hint: The TA solution is implemented using pgdir_walk, page_remove,
// and page2pa.
//
int
page_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)
{
	// Fill this function in
    cprintf("page_insert start, pp = %x, va = %x\n", pp, va);
    pte_t *pt = NULL;
    pte_t *pte = pgdir_walk(pgdir, va, 0);
    
    physaddr_t ptepa = 0x0000;
    physaddr_t ptpa = (physaddr_t)PTE_ADDR(pgdir[PDX(va)]);
    cprintf("page_insert, pt = %x, ptpa = %x\n", pgdir[PDX(va)], ptpa);
    if(ptpa)
    {
        cprintf("page_insert, there is page table = %x for va = %x, PTE_ADDR(pte) = %x\n", ptpa, va, PTE_ADDR(pte));
        if(*pte)
        {
            cprintf("page_insert, the page mapped at va has page = %x, remove it\n", *pte);
            page_remove(pgdir, va);
        }
    }
    else
    {
        cprintf("page_insert, there is no page table for va, create one and adds it to the pgdir\n");
        struct PageInfo *ptpg = page_alloc(ALLOC_ZERO);
        if(!ptpg)
        {
            cprintf("page_insert, alloc page for pt failure\n");
            return -E_NO_MEM;
        }
        ptpa = page2pa(ptpg);
        cprintf("page_insert, alloc page = %x for pt\n", ptpa);
        pgdir[PDX(va)] = ptpa | PTE_P | PTE_U | perm;
        cprintf("page_insert, PDX(va) = %d, pgdir[%d] = %x\n", PDX(va), PDX(va), pgdir[PDX(va)]);
        ptpg->pp_ref++;        
    }

    pt = page2kva(pa2page(ptpa));
    ptepa = page2pa(pp);
    cprintf("page_insert, insert page = %x to pt for va = %x\n", ptepa, va);
    
    pt[PTX(va)] = ptepa | PTE_P | perm;
    cprintf("PTX(va) = %d, pt[%d] = %x\n", PTX(va), PTX(va), pt[PTX(va)]);
    pp->pp_ref++;

    struct PageInfo *pre, *temp;
    pre = temp = page_free_list;
    cprintf("page_free, pp = %x, pre = %x\n", pp, pre);

    if(pre)
    {
        if(pre != pp)
        {
            do
            {
                temp = temp->pp_link;
//                cprintf("pre = %x, pre->pp_link = %x, temp = %x\n", pre, pre->pp_link, temp);
                if(temp == pp)
                {
                    cprintf("find pp = %x in free list, remove it from free list\n", pp);
                    pre->pp_link = temp->pp_link;
                    cprintf("page_free, find pp in free list\n");
                    break;
                }
            }while((pre = pre->pp_link));
        }   
        else
        {
            cprintf("page_free, find pp == pre\n");
            page_free_list = pre->pp_link;
        }   
    }

    cprintf("pp = %x, pp_ref = %d\n", pp, pp->pp_ref);

    cprintf("page_insert end\n");
    return 0;
}

//
// Return the page mapped at virtual address 'va'.
// If pte_store is not zero, then we store in it the address
// of the pte for this page.  This is used by page_remove and
// can be used to verify page permissions for syscall arguments,
// but should not be used by most callers.
//
// Return NULL if there is no page mapped at va.
//
// Hint: the TA solution uses pgdir_walk and pa2page.
//
struct PageInfo *
page_lookup(pde_t *pgdir, void *va, pte_t **pte_store)
{
	// Fill this function in
    cprintf("page_lookup start, va = %x, pte_store = %x\n", va, pte_store);
    pte_t *pte = pgdir_walk(pgdir, va, 0);
    cprintf("page_lookup, pte = %x, *pte = %x\n", pte, *pte);
    if(pte == NULL)
    {
        return NULL;
    }

    if(pte_store)
    {
        cprintf("pte_store is not NULL\n");
        pte_t *ptva = NULL;
        pte_t *pt = (pte_t *)PTE_ADDR(pgdir[PDX(va)]);
        ptva = (pte_t *)page2kva(pa2page((physaddr_t)PTE_ADDR(pt)));
        cprintf("entry addr = %x\n", &ptva[PTX(va)]);
        *pte_store = &ptva[PTX(va)];
        cprintf("**s = %x, *s = %x, s = %x, pt[PTX] = %x\n", **pte_store, *pte_store, pte_store, &pt[PTX(va)]);
    }
    pte_t *temp = (pte_t *)*pte;
    cprintf("page_lookup, temp = %x, pg = %x\n",temp,  pa2page(PTE_ADDR(*pte)));
    struct PageInfo *pg = pa2page(PTE_ADDR(*pte));
    cprintf("page_lookup end\n");
    return pg;
}

//
// Unmaps the physical page at virtual address 'va'.
// If there is no physical page at that address, silently does nothing.
//
// Details:
//   - The ref count on the physical page should decrement.
//   - The physical page should be freed if the refcount reaches 0.
//   - The pg table entry corresponding to 'va' should be set to 0.
//     (if such a PTE exists)
//   - The TLB must be invalidated if you remove an entry from
//     the page table.
//
// Hint: The TA solution is implemented using page_lookup,
// 	tlb_invalidate, and page_decref.
//
void
page_remove(pde_t *pgdir, void *va)
{
	// Fill this function in
    cprintf("page_remove start, va = %x\n", va);
    pte_t *pt = NULL;
    physaddr_t ptepa = 0x0000;
    physaddr_t ptpa = PTE_ADDR(pgdir[PDX(va)]);
    cprintf("PDX(va) = %d, pgdir[%d] = %x, ptpa = %x\n", PDX(va), PDX(va), pgdir[PDX(va)], ptpa);
    
    if(!ptpa)
    {
        cprintf("page_remove, has no page mapped at va = %x\n", va);
        return;
    }

    cprintf("page_remove, pagelookup start, pgdir = %x, va = %x\n", pgdir, va);
    struct PageInfo *pg = page_lookup(pgdir, va, NULL);
    cprintf("page_remove, va = %x corrsponding with pgInfo = %x\n", va, pg);

    pt = (pte_t *)page2kva(pa2page(ptpa));
    ptepa = PTE_ADDR(pt[PTX(va)]);
    cprintf("page_remove, pt = %x, ptepa = %x\n", pt, ptepa);
    if(ptepa)
    {
        cprintf("page_remove, ptepa = %x is not NULL, set pte to 0\n", ptepa);
        memset(&pt[PTX(va)], 0, sizeof(pte_t));
    }

    tlb_invalidate(pgdir, va);
    page_decref(pg);
    cprintf("page_remove end\n");
}

//
// Invalidate a TLB entry, but only if the page tables being
// edited are the ones currently in use by the processor.
//
void
tlb_invalidate(pde_t *pgdir, void *va)
{
	// Flush the entry only if we're modifying the current address space.
	// For now, there is only one address space, so always invalidate.
	invlpg(va);
}


// --------------------------------------------------------------
// Checking functions.
// --------------------------------------------------------------

//
// Check that the pages on the page_free_list are reasonable.
//
static void
check_page_free_list(bool only_low_memory)
{
	struct PageInfo *pp;
	unsigned pdx_limit = only_low_memory ? 1 : NPDENTRIES;
	int nfree_basemem = 0, nfree_extmem = 0;
	char *first_free_page;

	if (!page_free_list)
		panic("'page_free_list' is a null pointer!");

	if (only_low_memory) {
		// Move pages with lower addresses first in the free
		// list, since entry_pgdir does not map all pages.
		struct PageInfo *pp1, *pp2;
		struct PageInfo **tp[2] = { &pp1, &pp2 };
        int i = 0;
		for (pp = page_free_list; pp; pp = pp->pp_link) {
			int pagetype = PDX(page2pa(pp)) >= pdx_limit;
			*tp[pagetype] = pp;
			tp[pagetype] = &pp->pp_link;
		}
		*tp[1] = 0;
		*tp[0] = pp2;
		page_free_list = pp1;
	}
    cprintf("check page free list, page_free_list = %x\n", page_free_list);

	// if there's a page that shouldn't be on the free list,
	// try to make sure it eventually causes trouble.
    int i = 0;
	for (pp = page_free_list; pp; pp = pp->pp_link)
		if (PDX(page2pa(pp)) < pdx_limit)
            memset(page2kva(pp), 0x97, 128);

	first_free_page = (char *) boot_alloc(0);
    cprintf("check page free list, first free page = %x\n", first_free_page);

	for (pp = page_free_list; pp; pp = pp->pp_link) {
		// check that we didn't corrupt the free list itself
		assert(pp >= pages);
		assert(pp < pages + npages);
		assert(((char *) pp - (char *) pages) % sizeof(*pp) == 0);

		// check a few pages that shouldn't be on the free list
		assert(page2pa(pp) != 0);
		assert(page2pa(pp) != IOPHYSMEM);
		assert(page2pa(pp) != EXTPHYSMEM - PGSIZE);
		assert(page2pa(pp) != EXTPHYSMEM);
		assert(page2pa(pp) < EXTPHYSMEM || (char *) page2kva(pp) >= first_free_page);

		if (page2pa(pp) < EXTPHYSMEM)
			++nfree_basemem;
		else
			++nfree_extmem;
	}

	assert(nfree_basemem > 0);
	assert(nfree_extmem > 0);

	cprintf("check_page_free_list() succeeded!\n");
}

//
// Check the physical page allocator (page_alloc(), page_free(),
// and page_init()).
//
static void
check_page_alloc(void)
{
	struct PageInfo *pp, *pp0, *pp1, *pp2;
	int nfree;
	struct PageInfo *fl;
	char *c;
	int i;

	if (!pages)
		panic("'pages' is a null pointer!");

	// check number of free pages
	for (pp = page_free_list, nfree = 0; pp; pp = pp->pp_link)
		++nfree;
    cprintf("alloc three pages\n");
	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = page_alloc(0)));
	assert((pp1 = page_alloc(0)));
	assert((pp2 = page_alloc(0)));

	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
	assert(page2pa(pp0) < npages*PGSIZE);
	assert(page2pa(pp1) < npages*PGSIZE);
	assert(page2pa(pp2) < npages*PGSIZE);

    cprintf("set free_list = 0\n");
	// temporarily steal the rest of the free pages
	fl = page_free_list;
	page_free_list = 0;

	// should be no free memory
	assert(!page_alloc(0));

    cprintf("free pages\n");
	// free and re-allocate?
	page_free(pp0);
	page_free(pp1);
	page_free(pp2);
    cprintf("alloc three pages\n");
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = page_alloc(0)));
	assert((pp1 = page_alloc(0)));
	assert((pp2 = page_alloc(0)));
	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);
	assert(!page_alloc(0));

	// test flags
    cprintf("test flags\n");
	memset(page2kva(pp0), 1, PGSIZE);
	page_free(pp0);
	assert((pp = page_alloc(ALLOC_ZERO)));
	assert(pp && pp0 == pp);
	c = page2kva(pp);
	for (i = 0; i < PGSIZE; i++)
		assert(c[i] == 0);

	// give free list back
	page_free_list = fl;

	// free the pages we took
	page_free(pp0);
	page_free(pp1);
	page_free(pp2);

	// number of free pages should be the same
	for (pp = page_free_list; pp; pp = pp->pp_link)
		--nfree;
	assert(nfree == 0);

	cprintf("check_page_alloc() succeeded!\n");
}

//
// Checks that the kernel part of virtual address space
// has been set up roughly correctly (by mem_init()).
//
// This function doesn't test every corner case,
// but it is a pretty good sanity check.
//

static void
check_kern_pgdir(void)
{
	uint32_t i, n;
	pde_t *pgdir;

	pgdir = kern_pgdir;

	// check pages array
	n = ROUNDUP(npages*sizeof(struct PageInfo), PGSIZE);
	for (i = 0; i < n; i += PGSIZE)
    {
        assert(check_va2pa(pgdir, UPAGES + i) == PADDR(pages) + i);
    }

	// check phys mem
	for (i = 0; i < npages * PGSIZE; i += PGSIZE)
    {
//	    cprintf("i = %x, total = %x, rest = %x, check pa = %x\n", i, npages*PGSIZE, npages*PGSIZE - i, check_va2pa(pgdir, KERNBASE + i));
        assert(check_va2pa(pgdir, KERNBASE + i) == i);
    }

	// check kernel stack
	for (i = 0; i < KSTKSIZE; i += PGSIZE)
    {
	    cprintf("KSTACKTOP = %x, KSTKSIZE = %x, KSTACKTOP - KSTKSIZE + %x = %x\n", KSTACKTOP, KSTKSIZE, i, KSTACKTOP - KSTKSIZE + i);
        cprintf("PADDR(bootstack) = %x, PADDR + %x = %x\n", PADDR(bootstack), i, PADDR(bootstack) + i);
        assert(check_va2pa(pgdir, KSTACKTOP - KSTKSIZE + i) == PADDR(bootstack) + i);
    }
	assert(check_va2pa(pgdir, KSTACKTOP - PTSIZE) == ~0);

	// check PDE permissions
	for (i = 0; i < NPDENTRIES; i++) {
		switch (i) {
		case PDX(UVPT):
		case PDX(KSTACKTOP-1):
		case PDX(UPAGES):
			assert(pgdir[i] & PTE_P);
			break;
		default:
			if (i >= PDX(KERNBASE)) {
				assert(pgdir[i] & PTE_P);
				assert(pgdir[i] & PTE_W);
			} else
				assert(pgdir[i] == 0);
			break;
		}
	}
	cprintf("check_kern_pgdir() succeeded!\n");
}

// This function returns the physical address of the page containing 'va',
// defined by the page directory 'pgdir'.  The hardware normally performs
// this functionality for us!  We define our own version to help check
// the check_kern_pgdir() function; it shouldn't be used elsewhere.

static physaddr_t
check_va2pa(pde_t *pgdir, uintptr_t va)
{
	pte_t *p;

	pgdir = &pgdir[PDX(va)];
//    cprintf("check, pd = %x, *pd = %x, va = %x, PDX(va) = %x\n", pgdir, *pgdir, va, PDX(va));
	if (!(*pgdir & PTE_P))
		return ~0;
	p = (pte_t*) KADDR(PTE_ADDR(*pgdir));
//    cprintf("check, pt = %x, pt[%x] = %x\n", p, PTX(va), p[PTX(va)]);
	if (!(p[PTX(va)] & PTE_P))
		return ~0;
//    cprintf("check, pgaddr = %x\n", PTE_ADDR(p[PTX(va)]));
	return PTE_ADDR(p[PTX(va)]);
}


// check page_insert, page_remove, &c
static void
check_page(void)
{
	struct PageInfo *pp, *pp0, *pp1, *pp2;
	struct PageInfo *fl;
	pte_t *ptep, *ptep1;
	void *va;
	int i;
	extern pde_t entry_pgdir[];

	// should be able to allocate three pages
	pp0 = pp1 = pp2 = 0;
	assert((pp0 = page_alloc(0)));
	assert((pp1 = page_alloc(0)));
	assert((pp2 = page_alloc(0)));

	assert(pp0);
	assert(pp1 && pp1 != pp0);
	assert(pp2 && pp2 != pp1 && pp2 != pp0);

	// temporarily steal the rest of the free pages
	fl = page_free_list;
	page_free_list = 0;

	// should be no free memory
	assert(!page_alloc(0));

	// there is no page allocated at address 0
	assert(page_lookup(kern_pgdir, (void *) 0x0, &ptep) == NULL);

	// there is no free memory, so we can't allocate a page table
	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) < 0);

	// free pp0 and try again: pp0 should be used for page table
    cprintf("free pp0 and try again: pp0 should be used for page table\n");
	page_free(pp0);
	assert(page_insert(kern_pgdir, pp1, 0x0, PTE_W) == 0);
	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
	assert(check_va2pa(kern_pgdir, 0x0) == page2pa(pp1));
	assert(pp1->pp_ref == 1);
	assert(pp0->pp_ref == 1);

	// should be able to map pp2 at PGSIZE because pp0 is already allocated for page table
    cprintf("should be able to map pp2 at PGSIZE because pp0 is already allocated for page table\n");
	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
	assert(pp2->pp_ref == 1);

	// should be no free memory
    cprintf("should be no free memory\n");
	assert(!page_alloc(0));

	// should be able to map pp2 at PGSIZE because it's already there
    cprintf("should be able to map pp2 at PGSIZE because it's already there\n");
    cprintf("pp2 = %x\n", pp2);
	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
	assert(pp2->pp_ref == 1);

	// pp2 should NOT be on the free list
	// could happen in ref counts are handled sloppily in page_insert
	assert(!page_alloc(0));

	// check that pgdir_walk returns a pointer to the pte
    cprintf("check that pgdir_walk returns a pointer to the pte\n");
	ptep = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(PGSIZE)]));
    cprintf("ptep = %x, ptep + PTX(PGSIZE) = %x\n", ptep, ptep+PTX(PGSIZE));
	assert(pgdir_walk(kern_pgdir, (void*)PGSIZE, 0) == ptep+PTX(PGSIZE));

	// should be able to change permissions too.
    cprintf("should be able to change permissions too.\n");
	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W|PTE_U) == 0);
	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp2));
	assert(pp2->pp_ref == 1);
	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U);
	assert(kern_pgdir[0] & PTE_U);

	// should be able to remap with fewer permissions
	assert(page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W) == 0);
	assert(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_W);
	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));

	// should not be able to map at PTSIZE because need free page for page table
	assert(page_insert(kern_pgdir, pp0, (void*) PTSIZE, PTE_W) < 0);

	// insert pp1 at PGSIZE (replacing pp2)
	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W) == 0);
	assert(!(*pgdir_walk(kern_pgdir, (void*) PGSIZE, 0) & PTE_U));

	// should have pp1 at both 0 and PGSIZE, pp2 nowhere, ...
	assert(check_va2pa(kern_pgdir, 0) == page2pa(pp1));
	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
	// ... and ref counts should reflect this
	assert(pp1->pp_ref == 2);
	assert(pp2->pp_ref == 0);

	// pp2 should be returned by page_alloc
	assert((pp = page_alloc(0)) && pp == pp2);

	// unmapping pp1 at 0 should keep pp1 at PGSIZE
	page_remove(kern_pgdir, 0x0);
	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
	assert(check_va2pa(kern_pgdir, PGSIZE) == page2pa(pp1));
	assert(pp1->pp_ref == 1);
	assert(pp2->pp_ref == 0);

	// test re-inserting pp1 at PGSIZE
	assert(page_insert(kern_pgdir, pp1, (void*) PGSIZE, 0) == 0);
	assert(pp1->pp_ref);
	assert(pp1->pp_link == NULL);

	// unmapping pp1 at PGSIZE should free it
	page_remove(kern_pgdir, (void*) PGSIZE);
	assert(check_va2pa(kern_pgdir, 0x0) == ~0);
	assert(check_va2pa(kern_pgdir, PGSIZE) == ~0);
	assert(pp1->pp_ref == 0);
	assert(pp2->pp_ref == 0);

	// so it should be returned by page_alloc
	assert((pp = page_alloc(0)) && pp == pp1);

	// should be no free memory
	assert(!page_alloc(0));

	// forcibly take pp0 back
	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
	kern_pgdir[0] = 0;
	assert(pp0->pp_ref == 1);
	pp0->pp_ref = 0;

	// check pointer arithmetic in pgdir_walk
	page_free(pp0);
	va = (void*)(PGSIZE * NPDENTRIES + PGSIZE);
	ptep = pgdir_walk(kern_pgdir, va, 1);
	ptep1 = (pte_t *) KADDR(PTE_ADDR(kern_pgdir[PDX(va)]));
	assert(ptep == ptep1 + PTX(va));
	kern_pgdir[PDX(va)] = 0;
	pp0->pp_ref = 0;

	// check that new page tables get cleared
	memset(page2kva(pp0), 0xFF, PGSIZE);
	page_free(pp0);
	pgdir_walk(kern_pgdir, 0x0, 1);
	ptep = (pte_t *) page2kva(pp0);
	for(i=0; i<NPTENTRIES; i++)
		assert((ptep[i] & PTE_P) == 0);
	kern_pgdir[0] = 0;
	pp0->pp_ref = 0;

	// give free list back
	page_free_list = fl;

	// free the pages we took
	page_free(pp0);
	page_free(pp1);
	page_free(pp2);

	cprintf("check_page() succeeded!\n");
}

// check page_insert, page_remove, &c, with an installed kern_pgdir
static void
check_page_installed_pgdir(void)
{
	struct PageInfo *pp, *pp0, *pp1, *pp2;
	struct PageInfo *fl;
	pte_t *ptep, *ptep1;
	uintptr_t va;
	int i;

	// check that we can read and write installed pages
	pp1 = pp2 = 0;
	assert((pp0 = page_alloc(0)));
	assert((pp1 = page_alloc(0)));
	assert((pp2 = page_alloc(0)));
	page_free(pp0);
	memset(page2kva(pp1), 1, PGSIZE);
	memset(page2kva(pp2), 2, PGSIZE);
    cprintf("check page install, page_inseart pp1 start\n");
	page_insert(kern_pgdir, pp1, (void*) PGSIZE, PTE_W);
    cprintf("check page install, page_inseart pp1 end\n");
	assert(pp1->pp_ref == 1);
	assert(*(uint32_t *)PGSIZE == 0x01010101U);
    cprintf("check page install, page_inseart pp2 start\n");
	page_insert(kern_pgdir, pp2, (void*) PGSIZE, PTE_W);
    cprintf("check page install, page_inseart pp2 end\n");
	assert(*(uint32_t *)PGSIZE == 0x02020202U);
	assert(pp2->pp_ref == 1);
	assert(pp1->pp_ref == 0);
	*(uint32_t *)PGSIZE = 0x03030303U;
	assert(*(uint32_t *)page2kva(pp2) == 0x03030303U);
	page_remove(kern_pgdir, (void*) PGSIZE);
	assert(pp2->pp_ref == 0);

	// forcibly take pp0 back
	assert(PTE_ADDR(kern_pgdir[0]) == page2pa(pp0));
	kern_pgdir[0] = 0;
	assert(pp0->pp_ref == 1);
	pp0->pp_ref = 0;

	// free the pages we took
	page_free(pp0);

	cprintf("check_page_installed_pgdir() succeeded!\n");
}
